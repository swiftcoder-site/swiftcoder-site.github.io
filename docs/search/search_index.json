{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home page If you want to report errors you found on this website or want to discuss the content, create a ticket or a pull request at Github","title":"Home"},{"location":"#home-page","text":"If you want to report errors you found on this website or want to discuss the content, create a ticket or a pull request at Github","title":"Home page"},{"location":"design-patterns/creational-patterns/singleton/","text":"Singleton Singleton is a design pattern that gives a way to get the global access to an instance of a class and make sure there is only one instace of it. Steps to achieve this behaviour: Make constructor private Create static varible Let's look at the example: class ApiClient { static let shared = ApiClient () private init () { } } Now, we can access the instance of ApiClient by ApiClient.shared . Here is version with lazy initialisation. class ApiClient { // NOTE: Static veribles do not need lazy keywoard static var shared : ApiClient = { ApiClient () }() private init () { } }","title":"Singleton"},{"location":"design-patterns/creational-patterns/singleton/#singleton","text":"Singleton is a design pattern that gives a way to get the global access to an instance of a class and make sure there is only one instace of it. Steps to achieve this behaviour: Make constructor private Create static varible Let's look at the example: class ApiClient { static let shared = ApiClient () private init () { } } Now, we can access the instance of ApiClient by ApiClient.shared . Here is version with lazy initialisation. class ApiClient { // NOTE: Static veribles do not need lazy keywoard static var shared : ApiClient = { ApiClient () }() private init () { } }","title":"Singleton"},{"location":"sdk/threading/","text":"Kind of jobs might be perform in the separate threads Computation intensive jobs: When the thread uses entire processing capability of CPU. The reasonable maximum number of the threads is the number of CPU cores. By crating more threads we cause unnecessary switching of the context by the CPU, which takes some unit of time therefore it makes the calculation slower. I/O intensive jobs: In that case we can trigger more threads than we have CPU cores and there is a formula how we can calculate how many thread is an optimal Threads = Cores / (1- Blocking Factor ). Here the switch of CPU context itself does not impact much into performance, because the thread probably is waiting for a signal anyway. Mutex and the data consistency What makes threading difficult is the data consistency. Imagine the situation when there are two threads that have a pointer to the same array which suppose to contains unique items. Both threads can modify and read the array. Let's say both of the threads want to append the same item at exactly the same time to this array. What they do is to check if the item already exists in the array so they iterate through the array for checking the item if it is a duplicate and if not both of them will append it. The array will contains two the same items or even works the app will crash because the array might be mutated at the time the other threat iterate through it. The solution is to use mutex for blocking threads in order to avoid override the data. var mutex = pthread_mutex_t () pthread_mutex_init (& mutex , nil ) pthread_mutex_lock (& mutex ) // do atomic job pthread_mutex_unlock (& mutex ) pthread_mutex_destroy (& mutex ) Another mechanism for syncing thread is semaphore, but you need to be aware of potential deadlock. Below you can see one let semaphore = DispatchSemaphore ( value : 0 ) semaphore . wait () // DEADLOCK semaphore . signal () The current thread stops and wait for a signal that can not be send in this case, because we try to send it from the same thread which is stopped. Article abut mutexes NSObject The easiest way to start a new thread is to use a method that comes from base class NSObject performSelector ( inBackground : #selector ( job ), with : nil ) GCD (Grand Central Dispatch) The libdispatch is a part of core library which takes care about threading. In particular how to manage sync calls dispatch_once : Does not exists in SDK anymore [1] Here is an alternative private lazy var foo : Void = { // Do this once }() dispatch_sync : locks the current thread until the passed block is executed on the separated thread dispatch_async : starts executing the passed block on a separate thread, but the current one keeps running // without \"attributes\" we will get serial queue let queue = DispatchQueue ( label : \"important.job\" , qos : . default , attributes : . concurrent ) queue . async { // do stuff } DispatchQueue . main . async { < # code # > } DispatchQueue . global ( qos : . background ). async { < # code # > } Raywenderlich article serial vs concurrent queues This answer says that \" NSOperationQueue does use GCD on iOS 4.0 and later\" it says also quote: Prefer GCD where task is not much complex and optimum CPU performance is required. Prefer NSOperationQueue where task is complex and requires canceling or suspending a block and dependency management. Nice article that TODO: look at examples from the picture NSThread https://developer.apple.com/reference/foundation/thread This is the most let thread = Thread ( target : self , selector : #selector ( job ), object : nil ) // or let thread = Thread { < # code # > } // and then start the tread thread . start () NSOperationQueue [1] * How to cancel NSOperationQueue Blueprint of NSOperation class MyVeryExpensiveOperation : Operation { override func main () { if self . isCancelled { return } // Some chunk of time consuming task if self . isCancelled { return } // Some another chunk of time consuming task // and so on... } } Blueprint of NSOperationQueue let queue = OperationQueue () queue . name = \"Queue Name\" queue . maxConcurrentOperationCount = 1 let myOperation = MyVeryExpensiveOperation () queue . addOperation ( myOperation ) queue . addOperation { // some another job passed by block } pthread (advanced/JFYI) There is no good idea to handle threads from low level because it affect highly into development time of an application, whoever as all of us we are curious about everything, so I am going to show you how to do pthreading on iOS. Here is an example: var user_interactive_thread : pthread_t ? var user_interactive_qos_attr = pthread_attr_t () return_value = pthread_attr_init (& user_interactive_qos_attr ) return_value = pthread_attr_set_qos_class_np (& user_interactive_qos_attr , QOS_CLASS_USER_INTERACTIVE , 0 ) return_value = pthread_create (& user_interactive_thread , & user_interactive_qos_attr , { ( x : UnsafeMutableRawPointer ) in print ( \"New pthread job\" ) return nil }, nil )","title":"Threading"},{"location":"sdk/threading/#kind-of-jobs-might-be-perform-in-the-separate-threads","text":"Computation intensive jobs: When the thread uses entire processing capability of CPU. The reasonable maximum number of the threads is the number of CPU cores. By crating more threads we cause unnecessary switching of the context by the CPU, which takes some unit of time therefore it makes the calculation slower. I/O intensive jobs: In that case we can trigger more threads than we have CPU cores and there is a formula how we can calculate how many thread is an optimal Threads = Cores / (1- Blocking Factor ). Here the switch of CPU context itself does not impact much into performance, because the thread probably is waiting for a signal anyway.","title":"Kind of jobs might be perform in the separate threads"},{"location":"sdk/threading/#mutex-and-the-data-consistency","text":"What makes threading difficult is the data consistency. Imagine the situation when there are two threads that have a pointer to the same array which suppose to contains unique items. Both threads can modify and read the array. Let's say both of the threads want to append the same item at exactly the same time to this array. What they do is to check if the item already exists in the array so they iterate through the array for checking the item if it is a duplicate and if not both of them will append it. The array will contains two the same items or even works the app will crash because the array might be mutated at the time the other threat iterate through it. The solution is to use mutex for blocking threads in order to avoid override the data. var mutex = pthread_mutex_t () pthread_mutex_init (& mutex , nil ) pthread_mutex_lock (& mutex ) // do atomic job pthread_mutex_unlock (& mutex ) pthread_mutex_destroy (& mutex ) Another mechanism for syncing thread is semaphore, but you need to be aware of potential deadlock. Below you can see one let semaphore = DispatchSemaphore ( value : 0 ) semaphore . wait () // DEADLOCK semaphore . signal () The current thread stops and wait for a signal that can not be send in this case, because we try to send it from the same thread which is stopped. Article abut mutexes","title":"Mutex and the data consistency"},{"location":"sdk/threading/#nsobject","text":"The easiest way to start a new thread is to use a method that comes from base class NSObject performSelector ( inBackground : #selector ( job ), with : nil )","title":"NSObject"},{"location":"sdk/threading/#gcd-grand-central-dispatch","text":"The libdispatch is a part of core library which takes care about threading. In particular how to manage sync calls dispatch_once : Does not exists in SDK anymore [1] Here is an alternative private lazy var foo : Void = { // Do this once }() dispatch_sync : locks the current thread until the passed block is executed on the separated thread dispatch_async : starts executing the passed block on a separate thread, but the current one keeps running // without \"attributes\" we will get serial queue let queue = DispatchQueue ( label : \"important.job\" , qos : . default , attributes : . concurrent ) queue . async { // do stuff } DispatchQueue . main . async { < # code # > } DispatchQueue . global ( qos : . background ). async { < # code # > } Raywenderlich article serial vs concurrent queues This answer says that \" NSOperationQueue does use GCD on iOS 4.0 and later\" it says also quote: Prefer GCD where task is not much complex and optimum CPU performance is required. Prefer NSOperationQueue where task is complex and requires canceling or suspending a block and dependency management. Nice article that TODO: look at examples from the picture","title":"GCD (Grand Central Dispatch)"},{"location":"sdk/threading/#nsthread","text":"https://developer.apple.com/reference/foundation/thread This is the most let thread = Thread ( target : self , selector : #selector ( job ), object : nil ) // or let thread = Thread { < # code # > } // and then start the tread thread . start ()","title":"NSThread"},{"location":"sdk/threading/#nsoperationqueue","text":"[1] * How to cancel NSOperationQueue","title":"NSOperationQueue"},{"location":"sdk/threading/#blueprint-of-nsoperation","text":"class MyVeryExpensiveOperation : Operation { override func main () { if self . isCancelled { return } // Some chunk of time consuming task if self . isCancelled { return } // Some another chunk of time consuming task // and so on... } }","title":"Blueprint of NSOperation"},{"location":"sdk/threading/#blueprint-of-nsoperationqueue","text":"let queue = OperationQueue () queue . name = \"Queue Name\" queue . maxConcurrentOperationCount = 1 let myOperation = MyVeryExpensiveOperation () queue . addOperation ( myOperation ) queue . addOperation { // some another job passed by block }","title":"Blueprint of NSOperationQueue"},{"location":"sdk/threading/#pthread-advancedjfyi","text":"There is no good idea to handle threads from low level because it affect highly into development time of an application, whoever as all of us we are curious about everything, so I am going to show you how to do pthreading on iOS. Here is an example: var user_interactive_thread : pthread_t ? var user_interactive_qos_attr = pthread_attr_t () return_value = pthread_attr_init (& user_interactive_qos_attr ) return_value = pthread_attr_set_qos_class_np (& user_interactive_qos_attr , QOS_CLASS_USER_INTERACTIVE , 0 ) return_value = pthread_create (& user_interactive_thread , & user_interactive_qos_attr , { ( x : UnsafeMutableRawPointer ) in print ( \"New pthread job\" ) return nil }, nil )","title":"pthread (advanced/JFYI)"},{"location":"testing/dependency-injection/","text":"The app implementation First, we need to create the interface for our reposiotry that provides us the temperature for given location. In order to make the app more testable we will use the protocol defined below across the whole app instead of a class name that points to the final implementation. protocol TemperatureProviding { func temperature ( for location : CLLocation , result : ( Float64 ) -> Void ) } TemperatureProvider is the class that implements the real api calls and operates on real data, but the app will not use it directly in order to have possibility to mock the data repository. protocol TemperatureProvider : LoggerProviding { func temperature ( for location : CLLocation , result : ( Float64 ) -> Void ) // requesting the temperature from backend or whatever } } Every time when we want to use repository we need to inject it into the class using @Injected property wrapper. The point of it is that the TemperatureProvider user does not know the target implementation and not even care. struct TemperatureViewModel { @ Injected ( \\ . temperatureProvider ) var temperatureProvider : TemperatureProvider func loadData () { let location = CLLocation ( latitude : 49.9683988 , longitude : 20.7260966 ) temperatureProvider . temperature ( for : location , result : { temperature in print ( \"temperature is: \\( temperature ) \" ) } } } Define dependency 1st step: Depencency injector uses InjectionKey to register depencencies. It stores in the static property a currenct value for every key type (see next chapter to see implementation) Every class that is injected has to implement key and current value like this: private struct TemperatureProviderKey : InjectionKey { static var currentValue : TemperatureProviding = TemperatureProvider () } 2nd step: Extend InjectedValues and add propetry to it. It will link the exact InjectionKey implementation with the property. The property wrapper called like this @Injected(\\.temperatureProvider) will take the pey path, access InjectedValues and use keypath on it, and the getter of an injected propeperty will extract value from InjectionKey . extension InjectedValues { var temperatureProvider : TemperatureProviding { get { Self [ TemperatureProviderKey . self ] } set { Self [ TemperatureProviderKey . self ] = newValue } } } - InjectedValues[\\.temperatureProvider] = MockedTemperatureProvider() Implementation of dependency injector Let's define the protocol that defines the InjectionKey that holds current value public protocol InjectionKey { associatedtype Value static var currentValue : Self . Value { get set } } Here is how InjectedValues is defined. struct InjectedValues { private static var current = InjectedValues () private init () {} static subscript < K >( key : K . Type ) -> K . Value where K : InjectionKey { get { key . currentValue } set { key . currentValue = newValue } } static subscript < T >( _ keyPath : WritableKeyPath < InjectedValues , T >) -> T { get { current [ keyPath : keyPath ] } set { current [ keyPath : keyPath ] = newValue } } } and there is definition of the property wrapper @ propertyWrapper struct Injected < T > { private let keyPath : WritableKeyPath < InjectedValues , T > var wrappedValue : T { get { InjectedValues [ keyPath ] } set { InjectedValues [ keyPath ] = newValue } } init ( _ keyPath : WritableKeyPath < InjectedValues , T >) { self . keyPath = keyPath } }","title":"Dependency injection"},{"location":"testing/dependency-injection/#the-app-implementation","text":"First, we need to create the interface for our reposiotry that provides us the temperature for given location. In order to make the app more testable we will use the protocol defined below across the whole app instead of a class name that points to the final implementation. protocol TemperatureProviding { func temperature ( for location : CLLocation , result : ( Float64 ) -> Void ) } TemperatureProvider is the class that implements the real api calls and operates on real data, but the app will not use it directly in order to have possibility to mock the data repository. protocol TemperatureProvider : LoggerProviding { func temperature ( for location : CLLocation , result : ( Float64 ) -> Void ) // requesting the temperature from backend or whatever } } Every time when we want to use repository we need to inject it into the class using @Injected property wrapper. The point of it is that the TemperatureProvider user does not know the target implementation and not even care. struct TemperatureViewModel { @ Injected ( \\ . temperatureProvider ) var temperatureProvider : TemperatureProvider func loadData () { let location = CLLocation ( latitude : 49.9683988 , longitude : 20.7260966 ) temperatureProvider . temperature ( for : location , result : { temperature in print ( \"temperature is: \\( temperature ) \" ) } } }","title":"The app implementation"},{"location":"testing/dependency-injection/#define-dependency","text":"1st step: Depencency injector uses InjectionKey to register depencencies. It stores in the static property a currenct value for every key type (see next chapter to see implementation) Every class that is injected has to implement key and current value like this: private struct TemperatureProviderKey : InjectionKey { static var currentValue : TemperatureProviding = TemperatureProvider () } 2nd step: Extend InjectedValues and add propetry to it. It will link the exact InjectionKey implementation with the property. The property wrapper called like this @Injected(\\.temperatureProvider) will take the pey path, access InjectedValues and use keypath on it, and the getter of an injected propeperty will extract value from InjectionKey . extension InjectedValues { var temperatureProvider : TemperatureProviding { get { Self [ TemperatureProviderKey . self ] } set { Self [ TemperatureProviderKey . self ] = newValue } } } - InjectedValues[\\.temperatureProvider] = MockedTemperatureProvider()","title":"Define dependency"},{"location":"testing/dependency-injection/#implementation-of-dependency-injector","text":"Let's define the protocol that defines the InjectionKey that holds current value public protocol InjectionKey { associatedtype Value static var currentValue : Self . Value { get set } } Here is how InjectedValues is defined. struct InjectedValues { private static var current = InjectedValues () private init () {} static subscript < K >( key : K . Type ) -> K . Value where K : InjectionKey { get { key . currentValue } set { key . currentValue = newValue } } static subscript < T >( _ keyPath : WritableKeyPath < InjectedValues , T >) -> T { get { current [ keyPath : keyPath ] } set { current [ keyPath : keyPath ] = newValue } } } and there is definition of the property wrapper @ propertyWrapper struct Injected < T > { private let keyPath : WritableKeyPath < InjectedValues , T > var wrappedValue : T { get { InjectedValues [ keyPath ] } set { InjectedValues [ keyPath ] = newValue } } init ( _ keyPath : WritableKeyPath < InjectedValues , T >) { self . keyPath = keyPath } }","title":"Implementation of dependency injector"}]}